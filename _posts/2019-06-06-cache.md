---
layout: post
title:  "关于HTTP缓存"
date:   2019-06-4 17:35:05
categories:  cache
tags: cache
author: wisdom
---

* content
{:toc}

缓存从来都是前端的一个痛点，很多前端搞不太清楚缓存到底是何物，从而给自己创造了一些麻烦，

本文参考许多资料归纳总结，希望看完能对您有所帮助。



### (一) 前言：

* 掘金社区的: [缓存详解](https://juejin.im/post/5a6c87c46fb9a01ca560b4d7) 
* MDN Web 文档 [HTTP 缓存](https://juejin.im/post/5a6c87c46fb9a01ca560b4d7) 

>缓存是一种保存资源副本并且在下次请求时直接使用该副本的技术

说实话，我起始真的不知道怎么去介绍缓存，所以引用了上面相对官方的定义。

我想几乎每个开发者都碰到过缓存的问题吧，甚至有很多情况下我们会说这个问题已经修复了,你清理下缓存就好了。

这篇文章我们就细细的来挖掘下缓存的种种轶事。

### (二) 🦋缓存种类：

很多开发者习惯把**cookie**、**webStorage**以及**IndexedDB**存储的数据也称之为缓存，理由是都是保存在客户端的数据，没有什么区别。

其实这是不严谨的，cookie的存在更多的是为了让服务端区别用户，webStorage和IndexedDB则更多用在保存具体的数据和在客户端存储大量结构化数据(文件/blobs)上面。

缓存只有一种——**它是请求资源的副本**

#### 缓存的优势

纳尼？你问我为什么要缓存？😱

那就太容易说道了🤣，缓存好处有很多：

* 缓解服务器压力(不用每次去请求资源)；

* 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；

* 减少带宽消耗(我相信你可以理解)；


#### 宏观分类

缓存在宏观上可以分成两类：**私有缓存**和**共享缓存**。



共享缓存就是那些能被各级代理缓存的缓存(咋觉得有点绕)。

共享缓存存储的响应能够被多个用户使用。私有缓存只能用于单独用户。

![enter image description here](https://findwisdom.oss-cn-hongkong.aliyuncs.com/cache/HTTPCachtType.png)

##### (私有)浏览器缓存

私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。

浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。

它同样可以提供缓存内容的离线浏览。

##### (共享)代理缓存

共享缓存可以被多个用户使用。

例如，ISP CDN 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。

这样热门的资源就会被重复使用，减少网络拥堵与延迟。

### (三) 🦄浏览器的缓存策略

* 一个检索请求的成功响应: 对于 GET请求，响应状态码为：200，则表示为成功。一个包含例如HTML文档，图片，或者文件的响应；

* 不变的重定向: 响应状态码：301；

* 可用缓存响应：响应状态码：304，这个存在疑问，Chrome会缓存304中的缓存设置，Firefox；

* 错误响应: 响应状态码：404 的一个页面；

* 不完全的响应: 响应状态码 206，只返回局部的信息；

* 除了 GET 请求外，如果匹配到作为一个已被定义的cache键名的响应；

以上，对于我们可以和应该缓存的目标有个了解。🤗

**浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的。**

那么浏览器怎么确定一个资源该不该缓存，如何去缓存呢❓响应头！响应头！响应头！重要的事情说三遍。✌️

我们看🌰：

```
    Age:23146
    Cache-Control:max-age=2592000
    Date:Tue, 28 Nov 2017 12:26:41 GMT
    ETag:W/"5a1cf09a-63c6"
    Expires:Thu, 28 Dec 2017 05:27:45 GMT
    Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT
    Vary:Accept-Encoding
``` 

#### 1.强制缓存

以上请求头来自百度首页某个CSS文件的响应头。

* **Expires** 

是HTTP/1.0中的定义缓存的字段，它规定了缓存过期的一个**绝对时间**

* **Cache-Control:max-age=2592000**

是HTTP/1.1定义的关于缓存的字段，它规定了缓存过期的一个**相对时间**。

优先级上当然是版本高的优先了 `max-age > Expires`

这就是**强缓存阶段**，当浏览器再次试图访问这个CSS文件，发现有这个文件的缓存，

那么就判断根据上一次的响应判断是否过期，如果没过期，使用缓存。

Firefox浏览器表现为一个灰色的200状态码。

Chrome浏览器状态码表现为:

>200 (from disk cache)或是200 OK (from memory cache)

#### 2.协商缓存阶段

那么当这个CSS文件过期了怎么办?ETag和Last-Modified就该闪亮登场了。

* **Last-Modified**

这个字段是文件最后一次修改的时间；

* **ETag**

ETag是对文件的一个标记，嗯，可以这么说，具体生成方式HTTP并没有给出一个明确的方式，

所以理论上只要不会重复生成方式无所谓，比如对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。

利用这两个字段浏览器可以进入**协商缓存阶段**，当浏览器再次试图访问这个CSS文件，发现缓存过期，

于是会在本次请求的请求头里携带`If-Moified-Since`和`If-None-Match`这两个字段，

服务器通过这两个字段来判断资源是否有修改，如果有修改则返回状态码**200和新的内容**，

如果没有修改返回状态码**304**，浏览器收到**200**状态码，该咋处理就咋处理(相当于首次访问这个文件了)，

发现返回**304**，于是知道了本地缓存虽然过期但仍然可以用，于是加载本地缓存。然后根据新的返回的响应头来设置缓存。

(这一步有所差异，发现不同浏览器的处理是不同的，chrome会为304设置缓存，firefox则不会)😑

```
    If-Moified-Since: Tue, 28 Nov 2017 05:14:02 GMT
    If-None-Match: W/"5a1cf09a-63c6"
````

到这协商缓存结束

#### 3. 启发式缓存阶段

我们把上面的响应头改下：

```
    Age:23146
    Cache-Control: public
    Date:Tue, 28 Nov 2017 12:26:41 GMT
    Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT
    Vary:Accept-Encoding

```

发现没？浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？

有人可能会说下次请求直接进入协商缓存阶段，携带`If-Moified-Since`呗，不是的，浏览器还有个启发式缓存阶段😎

**根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。**

看下面这张图，来解释浏览器整个缓存策略的过程：

![enter image description here](https://findwisdom.oss-cn-hongkong.aliyuncs.com/cache/Free-Converter.com-16137f262e0adf18-2103853.jpg)


   
